* TODO solve, then test : hold a note, press sustain, release the note
** TODO found a bug : Window.Sustain: Using vid_to_pitch before it makes sense
`Su.handler` calls `toggleSustain` before `updateVoice`.
`updateVoice` assigns (among other things) pitches to voice ids.
`toggleSustain` calls `vid_to_pitch`.
** TODO PROGRESS! try debugging this
  st_f = st0 & fromRight meh . K.handler ((1,15),True)
  st_fs = st_f & fromRight meh . toggleSustain
  printSt st_f
  printSt st_fs
In st_fs, Lit field seems to have sustained the wrong pitch class -- 15 + 6 = 21, not 19.
They are otherwise identical.
** TODO lets try getting all the way there with handlers
add this code to Test/Windows.sh:

import Monome.Window.Keyboard as K
import Monome.Window.Shift    as Sh
import Monome.Window.Sustain  as Su

f = (1,15) -- key to play
st0_f     = st0    & fromRight meh . K.handler (f,True)    -- finger on
st0_fs    = st0_f  & Su.handler (meh,True) -- sustain off
-- st0_fs_rf = st0_fs & fromRight meh . K.handler (f,True)    -- finger off
(x,y) = (st0_f, st0_fs)
** TODO ? redundant : redundant Voice creation
`doSoundMessage` puts a new voice in the _stVoices field.
So does `Window.Common.updateVoice`.
`doSoundMessage` overwrites that, so it should all be good, but blech.
** buggy _stLit when (live) I finger a note and then sustain it
> printSt st_fs
Voices: []                                                                     Pending_Monome: []
Pending_Vivid: []
XyShift: (0,0)
Fingers: fromList [((1,15),(1,15))]
Lit: fromList [ (19,fromList [LedBecauseSustain]),
                (21,fromList [LedBecauseSwitch (1,15)])]
** here, it looks like Kbd.handler does everything right
If I start from synthetic data with 0 fingered and sustained,
and then use the handler to release the finger.

st = Su.handler (meh , True) st_0f -- sustain on
press@(xy,sw) = (xy0,False)              -- release finger.
st' = K.handler (xy, sw) st        -- release finger.
  -- Problem: Monome loses image, when it shouldn't.
  -- Problem: pending_Monome is empty, when it shouldn't be.

-- working through Kbd.handler
pcNow = mod (xyToEt31_st st xy) 31
pcThen :: Maybe PitchClass =
  ledBecause_toPitchClass (_stLit st) $ LedBecauseSwitch xy
fingers' = case sw of
  True  -> M.insert xy xy $ _stFingers st
  False -> M.delete xy    $ _stFingers st
lit' :: LitPitches = updateStLit (xy,sw) pcNow pcThen $ _stLit st
oldLitPcs :: Set PitchClass  = S.fromList $ M.keys $ _stLit st
newLitPcs :: Set PitchClass  = S.fromList $ M.keys $ lit'
toDark  ::    [PitchClass] = S.toList $ S.difference oldLitPcs newLitPcs
toLight ::    [PitchClass] = S.toList $ S.difference newLitPcs oldLitPcs
kbdMsgs :: [LedMsg] =
  map (K.label,) $
  (map (,False) $ concatMap (pcToXys $ _stXyShift st) toDark) ++
  (map (,True)  $ concatMap (pcToXys $ _stXyShift st) toLight)
soundMsgs :: [SoundMsg] = keyMsg st press
* TODO create voices on the fly
** TODO use nextVoice
Monome.Util.nextVoice :: M.Map VoiceId a -> VoiceId
** TODO use something other than pairs for voiceId
** PITFALLS
Create it before telling it to do something.
  Or else create it with those parameters.
Kill it after silencing it.
** how: sub-tasks
Monome.Util.nextVoice :: M.Map VoiceId a -> VoiceId
** how: loops
*** when a key is pressed
Ignore whether anything is sustaining, chords are playing, etc.
Get a new voiceId.
Create a voice with that ID and default parameters.
Send control messages as normal to it.
*** when a key is released
Look up whether it is sustained.
If not, turn it off, then kill it.
*** when a chord is sustained
Nothing different?
*** when a chord is released
in addition to "off", send "kill"
** optimize ? No need to turn it off.
** Vivid: voice creation, use and deletion
use "synth" to make a synth, "free" to free it:
  s <- synth boop ()
  set s (toI f :: I "amp")
  free s
* TODO sustained pitches should not disable keys
** after spatial drift
Currently, because each voice is identified with a key,
if that voice is sustained, that key cannot sound a new note,
even when it no longer represents the same pitch.
** ? or at all
* TODO features
** two keyboards, split keyboard
** timbre control, store timbre
** sustain: two buttons, "add these" and "release all"
"add these" has on/off state, stays in effect until it is released.
"release all" has no state -- it fires as soon as it's touched, and holding it does nothing.
** store pitchsets from sustain
** transpose {pitchsets, ongoing notes, either keyboard}
** make pitchsets available on a per-degree basis
** ? timbre-xy interaction
higher tones are harsher
rightward tones are (warblier?)
** redraw the whole screen often
*** why
Dropped messages to LEDs stop being a (hypothetical) problem.
Shading on both monomes becomes easier.
** flash the anchor
** volume, timbre control for {sustained notes, either keyboard}
** reset buttons
*** silence all voices
*** redraw entire grid
*** ? restore shift to identity vector
to remove floating point error
** sustain to middle of bottom, and duplicate at both top corners
so that usually something can touch it
* infrastructure
** add tests
*** TODO test multiple handlers
**** hold 2 notes, press sustain, shift, release one of them
**** hold 2 notes, press sustain, shift, release one of them, release sustain
**** hold a note, shift, press another note, press sustain
**** hold a note, shift, press another note, press sustain, release them
** LedBecause: maybe don't distinguish between keys and sustain
 just use VoiceId
* Montevideo - Monome Tidal Vivid
esp. for looping
* separate projects
** separate Vivid.Jbb from Vivid
this will make starting the repl faster
** separate my own Vivid projects
*** namely these
Vivid (clone, for reference)
Vivid.Synths.Jbb
Vivid.Dispatch
Monome
*** use symlinks between them as needed
e.g. from Monome to Synths
