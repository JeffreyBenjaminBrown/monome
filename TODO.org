* state
** which buttons are down
** which lights are on
** which buttons correspond to which voices
** which voices are playing what
* features
** light up enharmonics of pressed keys
*** TODO mystery: two functions from X,Y to PitchClass, one relative
*** overview
(Sustained keys will come later.)

Some things to maybe track:
  The keys under your fingers
  Which pitch classes to light up
  Which keys are responsible for a lit pitch class

When to do things
  Press a button
    Add it to the list of keys responsible for that pitch class
  Release a button
    Remove it from said list
    If said list is empty, dark that pitch class
*** functions to edit
colorAnchors ought to take a PitchClass and a keyboardShift value (x,y)

colorAnchors :: LedRelay -> Int -> Led -> IO ()

et31ToFreq :: Float -> Float
ought to take PitchClass and shift::(X,Y) as parameters

Shift.handler :: MVar State -> LedRelay -> [Window] 
  -> ((X,Y), Switch) -> IO ()
Currently darks old anchor, colors new anchor, changes anchor and shift.
Ought to take a PitchClass and a keyboardShift value (x,y),
  and use colorAnchors,
  and change the state of the keyboardshift but not the anchor

*** what uses anchors: Window.Shift, Window.Keyboard
*** what uses shift: Window.Shift, Window.Keyboard
** add to ongoing sustained group
** transpose ongoing notes
** save to chord bank from sustain
** sustained voices do not block keys
** sustain these and future
This is what most piano sustain pedals do.
The sustain that's programmed so far sustains only things under your fingers when you press the sustain button.
** loop bank
** timbre
** split keyboard
** reset buttons
*** silence all voices
*** redraw entire grid
*** restore shift to 1
to remove floating point error
* separate projects
** separate Vivid.Jbb from Vivid
 this will make starting the repl faster
** separate my own Vivid projects
*** namely these
Vivid (clone, for reference)
Vivid.Synths.Jbb
Vivid.Dispatch
Monome
*** use symlinks between them as needed
e.g. from Monome to Synths
