module Monome.JiScales where

import Data.List
import Data.Ratio

import Monome.Main
import Monome.Types.Initial
import Monome.Util


go :: IO (St JiApp)
go = do
  putStrLn $ show g1
  putStrLn $ show g2
  ji 14718 (fr <$> g1) (fr <$> g2)

g1, g2 :: [Rational]
g1 = sort $ fmap firstOctave diatonic
g2 = sort $ fmap firstOctave foo

diatonic, minor, major, foo :: [Rational]
diatonic = sort $ 10%9 : major -- Union of major and minor, appropriately transposed.
-- Major and minor are not transpositions of each other. If C = 1, then
-- in the C-major scale, the fifth from G to D is perfect,
-- while in the A-minor scale, the fifth from D to A is.
-- That is, the major scale has a howling Dorian mode,
-- while the minor scale has a howling Mixolydian.
minor = [1 % 1,9 % 8,6 % 5,4 % 3,3 % 2,8 % 5,9 % 5]
major = [1,9,5,4%3,3,5%3,15]
foo = [1,3,5,7,15,21] -- I like this as the other generator.
  -- I omit 35 because there are already so many different whole steps.

-- | to see every note generated by the two generators
cross :: (Fractional a, Ord a) => [a] -> [a] -> [a]
cross gen1 gen2 =
  sort . uniq . map firstOctave
  $ map (*) gen1 <*> gen2

-- | every interval in a scale
intervals :: (Fractional a, Ord a) => [a] -> [a]
intervals gen =
  sort . uniq . map firstOctave
  $ map (/) gen <*> gen

-- The intervals generated by both the major and the minor scale are
-- the same. There are 59 of them:
-- > cmi = cross minor minor
-- > cma = cross major major
-- > intervals cmi == intervals cma
-- True
-- > length $ uniq $ intervals cmi
-- 59
-- The diatonic scale generates another 66 more,
-- but I expect to ignore them.

showLabeled :: Show a => [a] -> IO ()
showLabeled = mapM_ (putStrLn . show) . zip [(1::Int) ..]

-- confusing
--g1 = sort . uniq $ firstOctave <$> [1..15]
--g2 = sort . uniq $ firstOctave <$> [1..9]

-- another idiom
-- x = sort $ firstOctave <$> ( filter (<= 7) primes
--                              ++ filter (>= (1%7)) subPrimes )

primes, subPrimes :: [Rational]
primes = [2,3,5,7,11,13,17,19,23,29,31]
subPrimes = map (1 /) $ tail primes

o1, firstOctave :: (Ord a, Fractional a) => a -> a
o1 = firstOctave
firstOctave n =
  -- this would work for floats:
  -- firstOctave frac = 2 ** mod' (log frac / log 2) 1
  if n >= 2 then firstOctave $ n/2
  else if n >= 1 then n
  else if n <= 0 then error "rejected: negative number."
  else firstOctave $ n*2
