module Monome.JiScales where

import Data.List
import Data.Ratio

import Monome.Main
import Monome.Types.Initial
import Monome.Util


go :: IO (St JiApp)
go = do
  putStrLn $ show g1
  putStrLn $ show g2
  ji 14718 (fr <$> g1) (fr <$> g2)

g1, g2 :: [Rational]
g1 = sort $ fmap o1 diatonic
g2 = sort $ fmap o1 foo

diatonic, minor, major, foo :: [Rational]
diatonic = sort $ 10%9 : major -- Union of major and minor, appropriately transposed.
minor = [1 % 1,9 % 8,6 % 5,4 % 3,3 % 2,8 % 5,9 % 5]
major = [1,9,5,4%3,3,5%3,15]
foo = [1,3,5,7,15,21] -- I like this as the other generator.
  -- I omit 35 because there are already so many different whole steps.

-- | to see every note generated by the two generators
cross :: (Fractional a, Ord a) => [a] -> [a] -> [a]
cross gen1 gen2 =
  sort . uniq . map o1
  $ map (*) gen1 <*> gen2

-- | every interval in a scale
intervals :: (Fractional a, Ord a) => [a] -> [a]
intervals gen =
  sort . uniq . map o1
  $ map (/) gen <*> gen

showLabeled :: Show a => [a] -> IO ()
showLabeled = mapM_ (putStrLn . show) . zip [(1::Int) ..]

-- very nice
--g1 = sort $ fmap o1 [1,9,5,4%3,3,5%3,15]
--g2 = sort $ fmap o1 [1,21,3,7]

-- confusing
--g1 = sort . uniq $ o1 <$> [1..15]
--g2 = sort . uniq $ o1 <$> [1..9]

-- another idiom
-- x = sort $ o1 <$> ( filter (<= 7) primes
--                     ++ filter (>= (1%7)) subPrimes )

primes, subPrimes :: [Rational]
primes = [2,3,5,7,11,13,17,19,23,29,31]
subPrimes = map (1 /) $ tail primes

o1, firstOctave :: (Ord a, Fractional a) => a -> a
o1 = firstOctave
firstOctave n =
  -- this would work for floats:
  -- firstOctave frac = 2 ** mod' (log frac / log 2) 1
  if n >= 2 then firstOctave $ n/2
  else if n >= 1 then n
  else if n <= 0 then error "rejected: negative number."
  else firstOctave $ n*2
